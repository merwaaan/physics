\section{Gestion des collisions}

Maintenant que la première section nous a éclairé sur la façon dont
les corps de la simulation évoluent indépendament les uns des autres,
il est temps de les faire interagir entre eux. Cette phase se divise
en trois étapes. Premièrement, le moteur physique doit être capable de
déterminer si une collision a lieu entre deux corps. Ensuite, il doit
pouvoir corriger leur état afin de contre-balancer les décalages dûs
aux erreurs numériques et à l'intégration discrète de
l'environnement. Finalement, une force de séparation doit être
calculée et appliquée aux deux objets afin de simuler le rebond ou le
repos.

\subsection{Détection}

Une collision fait entrer en jeu deux corps rigides dont l'intégrité
physique a été corrompue, autrement dit : les corps rentrent l'un dans
l'autre. Nous allons définir un traitement à appliquer à deux objets
pour savoir si tel est le cas et de façon certaine. Néanmoins, bien
que l'algorithme que nous allons présenter ait fait ses preuves
dans le domaine des simulations physiques, il faut garder à l'esprit
que ce test sera éxécuté à chaque intégration de la simulation et ce,
pour chaque paire de corps. Dans de telles circonstances, l'usage d'un
algorithme a priori rapide peut se révéler désastreux au niveau des
performances.

Nous faisons donc le choix de séparer la détection de collision en
deux étapes : une détection grossière et une détection fine. La
détection grossière fera usage d'un algorithme approximatif qui
informe de la possibilité d'une collision, si le résultat est positif
alors on exécute la détection fine (mais plus coûteuse) pour confirmer
ou infirmer le contact de façon certaine.

\subsubsection{Détection grossière}

Le but de la phase de détection grossière (\textit{broad-phase
  collision}) est de renseigner sur la possibilité d'une collision et
ce, à moindre coût. Si une collision a réellement lieu, le résultat
sera toujours positif, néanmoins il est aussi possible que le résultat
soit positif sans qu'aucune collision ne prenne vraiment place. Dans
ce dernier cas, la détection fine invalidera la collision.

On se base sur l'utilisation de boîtes englobantes, ou \textit{AABB}
(\textit{axis-aligned bounding-boxes}), pour détecter l'éventualité
d'un contact. Les boîtes englobantes sont des volumes alignés avec les
axes du repère global qui contiennent tous les points d'un corps. Pour
savoir si deux corps rentrent possiblement en collision, on vérifie si
leur boîte englobante entrent en collision.

Le processus de construction d'une boîte englobante est simple : on
enregistre pour chaque axe les deux points du corps qui sont les plus
éloignés dans les sens positifs et négatifs.

\begin{verbatim}
entrée : le corps C
sortie : une boîte englobant C

boite_englobante :
  boite.min = [INF, INF, INF]
  boite.max = [INF, INF, INF]

  Pour tous les axes
    Pour tous les points P de C
      Si P[axe] < boite.min[axe]
        boite.min[axe] = P[axe]
      Si P[axe] > boite.max[axe]
        boite.max[axe] = P[axe]

  retourner boite
\end{verbatim}

Le test vérifiant la collision entre deux boîtes englobantes est très
rapide puisque qu'il tire parti du fait que les boîtes sont alignées
avec le repère absolu. Pour vérifier que deux AABB sont en état
d'interpénétration, on utilise le théorème des axes de séparation
selon lequel deux boîtes sont séparées si leur projection sur au moins
un axe du repère absolu ne se superposent pas \cite{ericson05}. En
deux dimension, on peut résumer ce théorème par le fait que si une
ligne parallèle à un des axes du repère global sépare deux corps,
alors ils ne peuvent pas être en état de collision. En trois dimension
le principe est le même, à la différence que l'on parle de plan de
séparation.

\begin{verbatim}
entrée : deux boîtes englobantes b1 et b2
sortie : booléen

detection_collision_grossiere :
  Si b1.min[x] > b2.max[x] ou
     b1.max[x] < b2.min[x] ou
     b1.min[y] > b2.max[x] ou
     b1.max[y] < b2.min[x] ou
     b1.min[z] > b2.max[z] ou
     b1.max[z] < b2.min[z]
       retourner faux

  retourner vrai
\end{verbatim}

La figure \ref{aabb} illustre les trois situation possibles impliquant
deux corps.

Sur la sous-figure $a$, les boîtes englobantes ne rentrent pas en
collision car leur projection sur l'axe des abscisses ne se
superposent pas. Il est donc impossible que les corps qu'elles
contiennent soient eux-mêmes en état de collision, il est inutile
d'aller plus loin et de lancer la détection fine.

La sous-figure $b$ montre qu'il est possible dans certaines
configurations que les boîtes englobantes entrent en collision sans
que ce soit nécessairement le cas pour les corps qu'elles
contiennent. Les boîtes sont en état d'interpénetration puisque leurs
projections ne se séparent sur aucun axe. Ici, la détection grossière
renvoit un résultat positif et c'est l'algorithme de détection fine
qui réfutera la collision.

La sous-figure $c$ illustre quant à elle un troisième cas de figure
dans lequel les boîtes entrent en collision et les corps aussi.

\begin{figure}
  \centering
  \subfloat[]{ \input{images/boundingboxes1.tikz} }
  \qquad
  \subfloat[]{ \input{images/boundingboxes2.tikz} }
  \qquad
  \subfloat[]{ \input{images/boundingboxes3.tikz} }
  \caption{blabla}
  \label{aabb}
\end{figure}

\subsubsection{Détection fine}

La phase de détection fine (\textit{narrow-phase collision}) est plus
coûteuse mais détermine de façon certaine si deux corps sont en
collision.

Introduisons en premier lieu la somme de Minkowski, une opération
mathématique notée $A \oplus B = \{a + b \mid a \in A, b \in B\}$ avec
$A$ et $B$ deux corps. On peut résumer la somme de Minkowski en un
balayage de chaque corps par l'autre.

\begin{figure}
  \centering
  \subfloat[]{ \input{images/minkowski1.tikz} }
  \subfloat[]{ \input{images/minkowski2.tikz} }
  \caption{Différence de Minkowski entre un rectangle et un triangle}
  \label{minkowski}
\end{figure}

Nous utilisons une variante de cette opération : la différence de
Minkowski, notée $A \ominus B = A \oplus (-B)$. La propriété de cette
opération qui nous intéresse le plus est le fait que la plus petite
distance entre les points qui la forment et l'origine du repère absolu
est égale à la plus petite distance entre les corps $A$ et $B$ (figure
\ref{minkowski}). Nous pouvons exploiter cette caractéristique pour
déterminer si deux corps entrent en collision. En effet, si la
distance minimum entre les deux corps est supérieure à zéro, alors
aucune collision ne peut possiblement exister. Si au contraire, la
distance minimum est inférieure à zéro, alors les deux objets sont
état d'interpénétration.

Le processus de détection fine passera donc par le calcul de la
différence de Minkowski $M$ entre deux corps. Une fois $M$ calculée,
il reste encore à calculer la distance séparant $M$ et l'origine du
repère absolu. Dans cette optique, on utilise l'algorithme GJK, ou
\textit{Gilbert-Johnson-Keerthi algorithm}. De façon générale, cet
algorithme est capable de calculer efficacement la plus petite
distance entre la coque formée par un nuage de points et un point
précis de l'espace. Dans le cadre de notre problématique, le nuage de
points correspond aux vertex de $M$ et le point cible correspond à
l'origine du repère absolu.

GJK se base sur l'utilisation de simplex. Un simplex d'un corps est
une structure géométrique entièrement contenue dans ce dernier et
étant caractérisée par une dimension. Un simplex de dimension 0 est un
point, un simplex de dimension 1 est une ligne, une simplex de
dimension 2 est un triangle et un simplex de dimension 3 est un
tétrahèdre. Un corps de dimension $d$ peut contenir un simplex de
dimension $d$ au maximum. Le principe de GJK est de partir d'un
simplex de base choisi alétoirement (souvent un point, donc un simplex
de dimension 0) et d'augmenter sa dimension pour se rapprocher
progressivement du point de la figure le plus proche du point
cible. \`A la fin de cette procédure, on a determiné, le point de $M$
le plus proche de l'origine, et une simple soustraction vectorielle
permet de calculer leur distance.

\begin{figure}
  \centering

  \subfloat[]{ \input{images/gjk1a.tikz} }
  \subfloat[]{ \input{images/gjk1b.tikz} }
  \qquad
  \subfloat[]{ \input{images/gjk2a.tikz} }
  \subfloat[]{ \input{images/gjk2b.tikz} }
  \qquad
  \subfloat[]{ \input{images/gjk3a.tikz} }
  \subfloat[]{ \input{images/gjk3b.tikz} }

  \caption{{\'E}tapes de l'algorithme GJK}
  \label{gjk}
\end{figure}

La figure \ref{gjk} illustre la succession d'étapes qui amène à la
détermination du point le plus proche de l'origine $O$

\begin{itemize}
\item Le vertex $A$ est choisi aléatoirement pour faire office de
  simplex de base. Le point du simplex actuellement le plus proche de
  l'origine ne peu que être $A$. On cherche le vertex de la figure le
  plus extrême dans la direction du point le plus proche ($A$) à
  l'origine.
\item Le vertex le plus extrême est $C$, on l'ajoute au simplex. Le
  point du simplex le plus proche de l'origine est ???.
\item On cherche le vertex le plus extrême dans la direction de ??? à
  l'origine.
\item Le vertex le plus extrême est $B$, on l'ajoute au simplex. Le
  point du simplex le plus proche de l'origine est ???2.
\item Le vertex $A$ n'est plus utile à la définition du simplex
  contenant le point le point le plus proche de l'origine. On le
  retire du simplex. On cherche le vertex le plus extrême dans la
  direction de ???2 à l'origine.
\item Aucun vertex n'est plus extrême que ???2, on a donc le point de
  la figure le plus proche de l'origine.
\end{itemize}

\subsection{Correction}

\`A chaque mise à jour de la simulation, des corps sont susceptibles
de se déplacer et donc d'entrer en contact les uns avec les autres. Le
moteur simule ces évolutions par pas de temps fixe et il est donc
improbable qu'une collision soit détectée au moment exact o\`u elle se
produit (c'est à dire à l'instant précis o\`u les deux corps sont
posés l'un contre l'autre). On est donc en permanence témoin de
situations d'interpénétration au sein desquelles deux objets rentrent
l'un dans l'autre.  On pourrait ignorer cette imprécision et malgré
tout calculer les forces de rebond appropriées à ce contact mais
plusieurs situations critiques risquent d'apparaître. On pense
notamment au fait que la force de séparation calculée soit sensible à
cette erreur et ne déplace pas assez les corps à l'itération suivante
pour qu'ils soient séparés.

\begin{figure}
  \centering
  \input{images/interpenetration.tikz}
  \caption{Situation d'interpénétration}
\end{figure}

Pour trouver le point de contact réel entre deux objets en collision,
il existe plusieurs approches. Les systèmes préférant favoriser le
temps d'éxécution au détriment du réalisme se contentent de
repositionner les corps à un point de contact calculé en fonction de
la profondeur de l'interpénétration. Mais même si la position de
contact est corrigée par cette technique, il n'en sera pas de même
pour les autres quantités physiques. Le corps recalé aura une position
correcte mais son élan linéaire, par exemple, restera le même qu'à la
fin de l'intégration.  Même si la vitesse d'éxecution est un facteur
important dans nos choix de conception, nous allons prendre un chemin
différent et sélectionner une méthode plus précise qui fonctionnera
par retour en arrière.

La fonction d'intégration du moteur prend comme seul argument le pas
de temps duquel faire avancer la simulation et pour l'instant on
utilisait un pas constant. Or, une caractéristique intéressante de
cette fonction et qu'elle peut prendre en argument un pas de temps
négatif et simuler l'évolution d'un système en sens inverse. Cette
possibilité nous permet notamment de revenir en arrière dans la
simulation dés qu'une interpénétration est détectée et ce jusqu'à
retrouver le point de contact exact. Le terme "exact" est à prendre
avec des pincettes puisque le moteur physique est limitée par
l'arithmétique des nombres à virgules flottantes et que l'on doit se
contenter d'un résultat validé par un seuil de tolérance adapté. Le
pas de temps choisi devra correspondre à une fraction du pas de temps
originel puisque le but de cette man\oe uvre est de déterminer à quel
moment du pas de temps les corps sont réellement entrés en contact.

Usuellement, ce retour en arrière s'effectue en intégrant plusieurs
fois la simulation pas un pas de temps négatif et fixe, par exemple
$-\frac{\deriv t}{10}$. Néanmoins cette méthode s'adapte mal aux
simulations contenant des objets évoluant à hautes vitesses puisqu'en
utilisant cette même fraction du pas de temps, un corps s'étant
déplacé de dix mètres pendant l'intégration sera au moins recalé un
mètre avant tout contact réel, même si la profondeur de pénétration
n'était que de quelques centimètres.

Afin d'accélérer la phase de recherche on fait le choix de procéder
par dichotomie. \`A chaque étape $i$ de cette recherche, on recule de
$\frac{\deriv t}{2i}$ unité de temps si les corps s'interpénétrent,
sinon on avance de cette même durée. On considère qu'une position de
contact valide a été déterminée lorsqu'il n'y a plus
d'interpénétration et que la distance entre les objets est inférieure
à un seuil de tolérance choisi au préalable. Le processus est visible
sur la figure \ref{dichotomie}.

\begin{figure}
  \centering
  \input{images/dichotomie.tikz}
  \caption{Correction dichotomique de la configuration de contact}
  \label{dichotomie}
\end{figure}

\begin{verbatim}
entrée: deux corps A et B, le pas de temps
sortie: deux corps en collision exacte

correction:
  si collision_exacte(A,B)
    retourner A et B
  sinon si collision(A,B) alors
    A.integrer(-dt/2)
    B.integrer(-dt/2)
  sinon
    A.integrer(dt/2)
    B.integrer(dt/2)

\end{verbatim}

Une fois ce processus achevé, la configuration de contact est
retrouvée et les deux corps ne sont plus en situation de pénétration
mutuelle. On remarque que grâce à cette technique, la position n'est
pas la seule valeur à avoir été recalée : orientation, élans angulaire
et linéaires sont eux aussi revenus aux valeurs qu'ils auraient dû
atteindre à l'instant du contact.

\subsection{Réponse}

Un coefficient de restitution $0 \leq \varepsilon \leq 1$ détermine le
taux de rebond d'un corps. Si $\varepsilon = 1$, la balle rebondira
avec autant d'énergie qu'elle est arrivée (une situation concrètement
impossible à retrouver dans le monde réel). Si $\varepsilon = 0$, la
balle repartira avec une énergie nulle; autrement dit, elle restera
collée au plan. Le coefficient de restitution dépend habituellement de
la matière que l'on cherche à simuler : une balle en cahoutchouc aura
un $\varepsilon$ elevé tandis qu'un bloc d'argile aura un
$\varepsilon$ proche de zéro.

Le coefficient de friction influe sur la réponse rotationnelle qu'une
collision est susceptible de provoquer. Si la balle avait été laché, à
partir d'une vitesse nulle, sur un plan droit, le rebond aura été
purement linéaire. Dans le cas d'un plan incliné, un frottement non
perpendiculaire a lieu et la balle va entrer en rotation. Plus le
coefficient de friction est élevé et plus cet effet est puissant. On
peut simplifier cette notion en disant que le coefficient de friction
détermine si un corps est recouvert d'une matière qui accroche ou au
contraire qui glisse.

\cite{newton87}


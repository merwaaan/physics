\section{Dynamique} 

\subsection{La composante linéaire du mouvement}

Nous allons pour l'instant nous concentrer sur l'aspect cinématique d'un corps rigide, c'est à dire son mouvement lorsqu'il n'est soumis à aucune force extérieure. Dans un premier temps, seule la composante linéaire du mouvement sera étudiée et les objets dont nous allons simuler le comportement seront réduits à de simples particules. Les figures présentées sont en deux dimensions pour des raisons de clarté mais le principe reste similaire lorsqu'il est étendu à la troisième dimension.

La quantité physique la plus perceptible visuellement pour un spectateur est la position $p$ d'un corps. Pour notre affichage final, c'est cette valeur à tout instant $t$ de la simulation que l'on veut déterminer. Le travail de cette partie du moteur physique revient donc à déterminer la nouvelle position d'un objet à partir de la connaissance des forces qui lui sont appliquées. Un corps possède aussi une vitesse $v$, qui correspond à la variation de sa position pour une unité de temps. On note cette relation sous la forme dérivée :

\[\vec{v} = \frac{\delta \vec{p}}{\delta t}\]

Pareillement, l'accéleration $a$, qui apparaissaît plus tôt dans la seconde loi de Newton, correspond à la variation de la vitesse par rapport à une unité de temps.

\[\vec{a} = \frac{\delta \vec{v}}{\delta t}\]

Par transitivité, on confirme que la position est dépendante de l'accélération.

\[\vec{a} = \frac{\delta \vec{v}}{\delta t} = \frac{\delta^2 \vec{p}}{\delta t}\]

Grâce à cette équation, on peut calculer l'accélération d'un objet à partir de sa variation de position. Dans le moteur physique, ce sera en fait l'opération inverse qui devra être effectuée : on connaîtra les forces appliquées, on en déduira l'accélération induite par la seconde loi de Newton puis on calculera le changement de position. Il faut donc exploiter le fait que ces trois quantités partagent aussi des relations de primitive.

\[\vec{p} = \int \vec{v}\; \delta t = \int \vec{a}\; \delta t^2\]

Récapitulons. Chacun des corps rigides dont l'on veut simuler l'évolution possèdera ces trois quantités sous forme vectorielle et l'une des tâches de base du moteur physique sera de traduire l'application de forces en un changement de position. On sait qu'elles entretiennent des relations de dérivation, il faudra donc procéder par intégration pour calculer la position d'un objet à partir de son accélération.

\subsection{Intégration}

Dans la sous-section précédente, les trois quantités physiques entrant en jeu dans les mouvements linéaires ont été présentées. \'Etudions maintenant de façon plus concrète sur quels calculs se basera la partie la plus élémentaire du moteur physique.

Les phénomènes mécaniques du monde réel évoluent de façon continue mais notre simulation ne peut pas s'autoriser ce luxe. Le modèle du moteur physique sera donc discret et avancera par pas de temps fixe $\delta t$. \`A chaque mise à jour de la simulation, des intégrations doivent être réalisées pour déterminer le changement d'état d'un corps d'un instant $t_n$ à un instant $t_{n+1}$. Toujours pour des raisons d'efficacité, nous ne pouvont pas nous permettre d'allouer un temps de calcul trop important à cette phase de la mise à jour et nous devons trouver un moyen d'approximer ces intégrales.

Parmi les techniques classiques d'intégration approximative, on trouve l'intégration d'Euler. Cette méthode part du principe que l'on dispose de la valeur initiale $x_0$ de la quantité que l'on souhaite faire évoluer ainsi que de son taux de changement $x'$ et de la variation de temps par rapport à l'état précédent.

\[x_{n+1} = x_{n} + x' \delta t\]

Si l'on adapte cette idée à notre problème, on obtient la succession de calculs suivante :

\[a_{n+1} = \frac{\sum \vec{F}_i}{m}\]
\[\vec{v}_{n+1} = \vec{a}_n + \vec{a}_{n+1} \delta t\]
\[\vec{p}_{n+1} = \vec{p}_n + \vec{v}_{n+1} \delta t\]

On calcule l'accélération à un instant $t$ puis on intègre en fonction du temps jusqu'à obtenir la nouvelle position du corps. Ce processus doit être repété à chaque mise à jour du système et ce, pour chaque corps. On aurait pu choisir une autre méthode d'intégration, telle que l'intégration Runge-Kutta d'ordre 4 qui divise un pas de temps en plusieurs segments, ou bien telle que l'intégration de Verlet qui dispose d'une meilleure stabilité, mais Euler reste le choix le plus économique et fournit des résultats relativement corrects.

Afin de réduire la complexité de la structure informatique qui représentera un corps rigide, nous allons introduire la notion d'élan linéaire. Pour un corps rigide, l'élan linéaire $\vec{L}$ est le produit de la masse et de la vitesse. Cette nouvelle quantité a pour avantage majeur de posséder comme primitive la variation de force exercée sur le corps.

\[{\sum \vec{F}_i} = \frac{\delta \vec{L}}{\delta t} = \frac{\delta (m\vec{v})}{\delta t}\]

Ce qui signifie que l'on peut réduire l'intégration de l'état d'un corps à :

\[\vec{L}_{n+1} = \vec{L}_n + {\sum F}\]
\[\vec{p}_{n+1} = \vec{p}_n + \frac{\vec{L}_{n+1}}{m} t\]

L'élan linéaire remplace l'accélération dans la définition d'un corps et permet de calculer sa vitesse. Cette organisation permet à première vue une intégration plus courte mais les avantages majeurs de ce choix prendront tous leurs sens lorsque le mouvement angulaire sera introduit.

\subsection{Modélisation d'un corps rigide}

Nous avons décrit dans la partie précédente les quantités régissant le mouvement linéaire d'une particule ainsi que la façon dont elles évoluent mais le moteur physique que l'on conçoit a pour visée de simuler les interactions entre des corps rigides à volume convexe. Comment peut-on étendre les principes énoncés pour des particules à ce modèle ?

On pourrait en premier lieu penser à représenter un tel corps par une liste de particules, chacune placée à un coin de l'objet. Chaque particule évoluerait indépendement et des contraintes de cohésion entre particules voisines seraient appliquées pour empêcher toute déformation du corps. Cette méthode est envisageable mais elle présente plusieurs désavantages. Premièrement, les règles de cohésion à mettre en place nécessiteraient des traitements supplémentaires, et donc un temps de calcul plus élevé. Deuxièment, un corps devrait passer par autant d'intégrations qu'il a de points à chaque mise à jour. Il existe une solution plus simple et plus élégante qui permet de réduire les mouvements linéaires d'un corps rigide à ceux d'une unique particule judicieusement placée.

Introduisons en premier lieu la notion de repères absolu et local. Le repère absolu est le référentiel orthogonal dont l'origine sert de centre à l'environnement de la simulation. Un repère local est un référentiel qui est unique à chaque corps et dont le centre se situe à l'intérieur même de cet objet.

\input{images/reperelocal.tikz}

La position exacte du repère local dépend de la position des points qui forment l'objet mais il ne s'agit pas d'un simple centre géométrique puisque la masse de chaque point est aussi un facteur déterminant. Cette position se nomme le centre de masse, ou barycentre, et sera calculée par la formule suivante, o\`u $M$ représente la masse totale des points, et $m_i$ et $\vec{p}_i$ respectivement la masse et la position dans le repère absolu du point $i$.

\[C = \frac{1}{M} \sum m_i \vec{p}_i\]

Une fois le centre de masse défini, la position locale $\vec{r}_i$ d'une particule $i$ peut être calculée en fonction de sa position absolue $\vec{p}_i$ par :

\[\vec{r}_i = \vec{p}_i - C\]

Le processus de définition d'un corps se déroule comme suit :
\begin{enumerate}
  \item{L'utilisateur entre les points de l'objet un par un, dans le repère absolu}
  \item{L'utilisateur renseigne les points qui sont reliés par des arête afin de former les faces de l'objet}
  \item{Le centre de masse est automatiquement calculé avant la simulation}
\end{enumerate}

Grâce au centre de masse, on a une seule position à faire évoluer, quelle que soit la compléxité de la structure du corps concerné.

\subsection{La composante angulaire du mouvement}

Le modèle que nous avons défini est encore incomplet puisqu'il ne prend pas en compte la composante rotationnelle des mouvements dont l'on peut être témoin dans un environnement réel. Les particules étant de simples points flottants dans l'espace, cela ne posait pas de problème précédemment mais le moteur physique que l'on conçoit doit gérer des corps rigiques plus complexes. Imaginons une boîte cubique que l'on lancerait en l'air, si aucune rotation n'apparaît (si la base de la boîte reste parallèle au sol), l'imitation du réel que l'on souhaite reproduire perd toute crédibilité.

Les quantités physiques entrant en jeu dans la décomposition d'un déplacement angulaire sont analogues à celle présentées dans la partie traitant de la dynamique linéaire : à la position et à l'élan linéaire correspondent l'orientation et l'élan angulaire.

\subsubsection{L'orientation}

De la même façon que la position représentait visuellement l'état d'un corps au sein de la composante linéaire, un corps doit posséder une orientation. En deux dimensions, un nombre flottant représentant l'angle du corps par rapport à un axe fixe suffirait à décrire l'orientation d'un objet mais pas dans notre environnement en trois dimensions.

Le repère local d'un corps a été introduit dans la partie précédente et se résumait à un centre de masse faisant office d'origine, mais un repère possède aussi des axes et ceux du repère local ne sont pas nécessairement alignés avec ceux du repère absolu. Pour représenter la direction des axes du repère local, et donc l'orientation, on utilisera une matrice de dimension trois au sein de laquelle chaque vecteur colonne correspondra à un des axes du repère local \cite{witkit97}. Pour illustrer ces propos, analysons la matrice d'orientation égale à la matrice d'identité d'ordre 3.

\[
\begin{pmatrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  0 & 0 & 1
\end{pmatrix}
\rightarrow
\begin{pmatrix}
  1 \\
  0 \\
  0 
\end{pmatrix}
\begin{pmatrix}
  0 \\
  1 \\
  0 
\end{pmatrix}
\begin{pmatrix}
  0 \\
  0 \\
  1 
\end{pmatrix}
\]

Si l'on isole les vecteurs colonnes de cette matrice identité, on remarque que chacun correspond à un des axes du repère global. Le premier vecteur colonne d'une matrice d'orientation correspond donc à l'axe $x$ du repère local. Il en est de même pour la seconde colonne avec l'axe $y$ et la troisième colonne avec l'axe $z$.

\subsubsection{\'Elan angulaire}

Il nous faut désormais représenter le taux de variation de l'orientation d'un corps. La vitesse angulaire sera représentée par un vecteur dont la direction correspondra à l'axe autour duquel le corps effectuera sa rotation et dont la magnitude représentera le nombre de rotations à effectuer en une unité de temps. La relation entre orientation et élan angulaire est plus complexe que celle reliant position et élan linéaire.

intégration

torseur inertie

skew

reorthogonalisation

etc

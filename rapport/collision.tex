\section{Gestion des collisions}

Maintenant que la première section nous a éclairé sur la façon dont
les corps de la simulation évoluent indépendament les uns des autres,
il est temps de les faire interagir entre eux. Cette phase se divise
en trois étapes. Premièrement, le moteur physique doit être capable de
déterminer si une collision a lieu entre deux corps. Ensuite, il doit
pouvoir corriger leur état afin de contre-balancer les décalages dûs
aux erreurs numériques et à l'intégration discrète de
l'environnement. Finalement, une force de séparation doit être
calculée et appliquée aux deux objets afin de simuler le rebond ou le
repos.

\subsection{Détection d'une collision}

Une collision fait entrer en jeu deux corps rigides dont l'intégrité
physique a été corrompue, autrement dit : les corps rentrent l'un dans
l'autre. Nous allons définir un traitement à appliquer à deux objets
pour savoir si tel est le cas et de façon certaine. Néanmoins, bien
que l'algorithme que nous allons fait ses preuves ait fait ses preuves
dans le domaine des simulations physique, il faut garder à l'esprit
que ce test sera éxécuté à chaque intégration de la simulation et ce,
pour chaque paire de corps. Dans de telles circonstances, l'usage d'un
algorithme a priori rapide peut se révéler désastreux au niveau des
performances.

Nous faisons donc le choix de séparer la détection de collision en
deux étapes : une détection grossière et une détection fine. La
détection grossière fera usage d'un algorithme approximatif qui
informe de la possibilité d'une collision, si le résultat est positif
alors on exécute la détection fine (mais plus coûteuse) pour confirmer
ou infirmer le contact de façon certaine.

\subsubsection{Détection grossière}

Le but de la phase de détection grossière (\textit{broad-phase
  collision}) est de renseigner sur la possibilité d'une collision et
ce, à moindre coût. Si une collision a réellement lieu, le résultat
sera toujours positif, néanmoins il est possible que le résultat soit
positif sans qu'il y ait de collision réelle. Dans ce dernier cas, la
détection fine invalidera la collision.

On se base sur l'utilisation de boîtes englobantes, ou AABB
(\textit{axis-aligned bounding-boxes}), pour détecter l'éventualité
d'un contact. Les boîtes englobantes sont des volumes alignés avec les
axes du repère global et contenant tous les points d'un corps. Pour
savoir si deux corps rentrent possiblement en collision, on vérifie si
leurs boîtes englobantes entrent en collision.

La construction d'une boîte englobante revient à enregistrer les deux
points les plus extrêmes d'un corps (dans le sens négatif et dans le
sens positif) et ce pour tous les axes de l'environnement de la simulation.

\begin{verbatim}
construire_boite_englobante :
  boite.min = [ ]
  boite.max = [ ]

  Pour tous les points du corps
    Pour tous les axes
      Si point[axe] < boite.min[axe]
        boite.min[axe] = point[axe]
      Si point[axe] > boite.max[axe]
        boite.max[axe] = point[axe]
\end{verbatim}

Le test vérifiant la collision entre deux boîtes englobantes est très
rapide puisque qu'il tire parti du fait que les boîtes sont alignées
avec le repère absolu et qu'on peut pour vérifier que deux AABB son en
état d'interpénétration il suffit de vérifier qu'elles ne sont pas
séparées sur tous les axes \cite{ericson05}.

\begin{verbatim}
detection_collision_grossiere :
  Si b1.min[x] > b2.max[x] ou
     b1.max[x] < b2.min[x] ou
     b1.min[y] > b2.max[x] ou
     b1.max[y] < b2.min[x] ou
     b1.min[z] > b2.max[z] ou
     b1.max[z] < b2.min[z]
       retourner faux

  retourner vrai
\end{verbatim}

\begin{figure}
  \subfigure{ \input{images/boundingboxes1.tikz} }
  \subfigure{ \input{images/boundingboxes2.tikz} }
  \subfigure{ \input{images/boundingboxes3.tikz} }
\end{figure}

\subsubsection{Détection fine}

La phase de détection fine (\textit{narrow-phase collision}) est plus
coûteuse mais détermine de façon certaine si deux corps sont en
collision.

Introduisons en premier lieu la somme de Minkowski, une opération
mathématique notée $A \oplus B = \{a + b \mid a \in A, b \in B\}$ avec
$A$ et $B$ deux corps. On peut résumer la somme de Minkowski en un
balayage de chaque corps impliqué dans cette opération par l'autre.

\begin{figure}
  \input{images/minkowskisum.tikz}
  \caption{Somme de Minkowski entre un rectangle et un cercle}
\end{figure}

Nous utilisons une variante de cette opération : la différence de
Minkowski, notée $A \ominus B = A \oplus (-B)$. La propriété de cette
opération qui nous intéresse le plus est le fait que la plus petite
distance entre les points qui la forment et l'origine du repère absolu
est égale à la plus petite distance entre les corps $A$ et $B$. Nous
pouvons exploiter cette caractéristique pour déterminer si deux corps
entrent en collision. En effet, si la distance minimum entre les deux
corps est supérieure à zéro, alors aucune collision ne peut
possiblement exister. Si au contraire, la distance minimum est
inférieure à zéro, alors les deux objets sont état d'interpénétration.

Le processus de détection fine passera donc par le calcul de la
différence de Minkowski $M$ entre deux corps. Une fois $M$ calculée,
il reste encore à calculer la distance séparant $M$ et l'origine du
repère absolu. Dans cette optique, on utilise l'algorithme GJK, ou
\textit{Gilbert-Johnson-Keerthi algorithm}. De façon générale, cet
algorithme est capable de calculer efficacement la plus petite
distance entre la coque formée par un nuage de points et un point
précis de l'espace. Dans le cadre de notre problématique, le nuage de
points correspond aux vertex de $M$ et le point cible correspond à
l'origine du repère absolu.

GJK se base sur l'utilisation de simplex. Un simplex d'un corps est
une structure géométrique entièrement contenue dans ce dernier et
étant caractérisée par une dimension. Un simplex de dimension 0 est un
point, un simplex de dimension 1 est une ligne, une simplex de
dimension 2 est un triangle et un simplex de dimension 3 est un
tétrahèdre. Un corps de dimension $d$ peut contenir un simplex de
dimension $d$ au maximum. Le principe de GJK est de partir d'un
simplex de base choisi alétoirement (souvent un point, donc un simplex
de dimension 0) et d'augmenter sa dimension pour se rapprocher
progressivement du point de la figure le plus proche du point
cible. \`A la fin de cette procédure, on a determiné, le point de $M$
le plus proche de l'origine, et une simple soustraction vectorielle
permet de calculer leur distance.

\begin{figure}
  \input{images/gjk.tikz}
  \caption{{\'E}tapes de l'algorithme GJK}
  \label{gjk}
\end{figure}

La figure \ref{gjk} illustre la succession d'étapes qui amène à la
détermination du point le plus proche de l'origine $O$

\begin{itemize}
\item Le point $A$ est choisi aléatoirement pour faire office de
  simplex de base. Le point actuellement le plus proche de l'origine
  est naturellement $A$.
\item On cherche le point de la figure le plus extrême dans la
  direction du point actuellement le plus proche ($A$) à
  l'origine. C'est le point $C$. On l'ajoute au simplex.
\item On détermine le point du simplex le plus proche de l'origine
  ($p_1$) et on calcule quel est le point de la figure le plus extrême
  dans la direction de ce point à l'origine. C'est le point $B$.
\item Le simplex a atteint une dimension de 2 mais le point $A$ n'est
  plus utile à la définition du point actuellement le plus proche. On
  le retire du simplex.
\item On cherche le point du simplex le plus proche de l'origine et on
  détermine quel est le point de la figure le plus extrême dans sa
  direction vers l'origine. Aucun n'est plus extrême que le point
  actuellement le plus proche, on peut donc arrêter la recherche.
\end{itemize}

\subsection{Correction d'une collision}

\`A chaque itération de la simulation, les corps présents dans
l'environnement du moteur physique sont susceptibles de se déplacer et
donc d'entrer en contact. Le moteur simule ces évolutions de manière
discrète et il est très improbable qu'une collision soit détectée au
moment précis o\`u elle se produit. On est donc régulièrement témoin
de situations d'inter-pénétration au sein desquelles des corps
rentrent l'un dans l'autre.

DESSIN : inter-pénétration

On pourrait se satisfaire de cette imprécision et calculer les forces
de rebond appropriées mais plusieurs situations critiques risquent
d'apparaître. Pour trouver le point de contact réel entre deux objets,
il existe plusieurs approches. Les systèmes préférant favoriser le
temps d'éxécution au détriment du réalisme se contentent de
repositionner les corps à un point de contact calculé par
interpolation en fonction du temps de la dernière intégration. Il est
évident que des objets sujets à des déplacements non linéaires
(variation de la vitesse pendant un pas de temps, trajectoire
elliptique) seront mal replacés.

Même si la vitesse d'éxecution est un facteur important dans nos choix
de conception, nous allons prendre un chemin différent et sélectionner
une méthode plus précise qui fonctionnera par retour en arrière. La
fonction d'intégration du moteur prend comme seul argument le pas de
temps duquel faire avancer la simulation et pour l'instant on
utilisait un pas constant. Or, une caractéristique intéressante de
cette fonction et qu'elle peut prendre en argument un pas de temps
négatif et simuler en sens inverse. Grâce à cette caractéristique, dés
qu'une inter-pénétration est détectée, on peut revenir en arrière
jusqu'à retrouver le temps de contact exact. Le terme "exact" est à
prendre avec des pincettes puisque notre simulation est limitée par
l'arithmétique des nombres à virgules flottantes et que l'on devra se
contenter d'un résultat quasi-exact, validé par un seuil de tolérance
adapté.

Afin d'accélérer cette phase de recherche de la configuration de
contact, le retour en arrière se fera par dichotomie. On recule en
premier lieu de la moitié du pas de temps puis, si l'inter-pénétration
est toujours présente, on recule d'un quart du pas de temps, sinon on
avance d'un quart du pas de temps, et ainsi de suite jusqu'à obtenir
une précision satisfaisante.

ALGORITHME

DESSIN : recherche de la vraie position de contact

Une fois ce processus achevé, la configuration de contact est
retrouvée et les deux corps ne sont plus en situation de pénétration
mutuelle. On remarque que grâce à cette technique, la position n'est
pas la seule valeur à avoir été recalée : orientation, élans angulaire
et linéaires sont eux aussi revenus à leurs valeurs au moment du
contact.

\subsection{Réponse à une collision}

Un coefficient de restitution $0 \leq \varepsilon \leq 1$ détermine le
taux de rebond d'un corps. Si $\varepsilon = 1$, la balle rebondira
avec autant d'énergie qu'elle est arrivée (une situation concrètement
impossible à retrouver dans le monde réel). Si $\varepsilon = 0$, la
balle repartira avec une énergie nulle; autrement dit, elle restera
collée au plan. Le coefficient de restitution dépend habituellement de
la matière que l'on cherche à simuler : une balle en cahoutchouc aura
un $\varepsilon$ elevé tandis qu'un bloc d'argile aura un
$\varepsilon$ proche de zéro.

Le coefficient de friction influe sur la réponse rotationnelle qu'une
collision est susceptible de provoquer. Si la balle avait été laché, à
partir d'une vitesse nulle, sur un plan droit, le rebond aura été
purement linéaire. Dans le cas d'un plan incliné, un frottement non
perpendiculaire a lieu et la balle va entrer en rotation. Plus le
coefficient de friction est élevé et plus cet effet est puissant. On
peut simplifier cette notion en disant que le coefficient de friction
détermine si un corps est recouvert d'une matière qui accroche ou au
contraire qui glisse.

\cite{newton87}

